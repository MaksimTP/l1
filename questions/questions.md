# L1 Устные вопросы

## 1. Какой самый эффективный способ конкатенации строк

![alt text](images/benchResults.png)

## 2. Что такое интерфейсы, как они применяются в Go?


Интерфейсный тип в Go — это своего рода определение. Он определяет и описывает конкретные методы, которые должны быть у какого-то другого типа.

Одним из интерфейсных типов из стандартной библиотеки является интерфейс fmt.Stringer:

```go
type Stringer interface {
    String() string
}
```

Мы говорим, что что-то удовлетворяет этому интерфейсу (или реализует этот интерфейс), если у этого «что-то» есть метод с конкретным сигнатурным строковым значением String().

Например, тип Book удовлетворяет интерфейсу, потому что у него есть строковый метод String():

```go
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}
```

Неважно, каким типом является Book или что он делает. Важно лишь, что у него есть метод под названием String(), который возвращает строковое значение.

А вот другой пример. Тип Count тоже удовлетворяет интерфейсу fmt.Stringer, потому что у него есть метод с тем же сигнатурным строковым значением String().


```go
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}
```

Здесь важно понять, что у нас есть два разных типа Book и Count, которые действуют по-разному. Но их объединяет то, что они оба удовлетворяют интерфейсу fmt.Stringer.

Можете посмотреть на это с другой стороны. Если вы знаете, что объект удовлетворяет интерфейсу fmt.Stringer, то можете считать, что у него есть метод с сигнатурным строковым значением String(), которое вы можете вызывать.

А теперь самое важное.

Когда вы видите в Go объявление (переменной, параметра функции или поля структуры), имеющее интерфейсный тип, вы можете использовать объект любого типа, пока он удовлетворяет интерфейсу.

Допустим, у нас есть функция:


```go
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}
```

Поскольку WriteLog() использует в объявлении параметра интерфейсный тип fmt.Stringer, мы можем передавать любой объект, удовлетворяющий интерфейсу fmt.Stringer. Например, можем передать типы Book и Count, которые создали ранее в методе WriteLog(), и код будет нормально работать.

Кроме того, поскольку передаваемый объект удовлетворяет интерфейсу fmt.Stringer, мы знаем, что у него есть строковый метод String(), который может быть безопасно вызван функцией WriteLog().

Давайте соберём всё сказанное в один пример, демонстрирующий мощь интерфейсов.

```go
package main

import (
    "fmt"
    "strconv"
    "log"
)

// Объявляем тип Book, который удовлетворяет интерфейсу fmt.Stringer.
type Book struct {
    Title  string
    Author string
}

func (b Book) String() string {
    return fmt.Sprintf("Book: %s - %s", b.Title, b.Author)
}

// Объявляем тип Count, который удовлетворяет интерфейсу fmt.Stringer.
type Count int

func (c Count) String() string {
    return strconv.Itoa(int(c))
}

// Объявляем функцию WriteLog(), которая берёт любой объект,
// удовлетворяющий интерфейсу fmt.Stringer в виде параметра.
func WriteLog(s fmt.Stringer) {
    log.Println(s.String())
}

func main() {
    // Инициализируем объект Book и передаём в WriteLog().
    book := Book{"Alice in Wonderland", "Lewis Carrol"}
    WriteLog(book)

    // Инициализируем объект Count и передаём в WriteLog().
    count := Count(3)
    WriteLog(count)
}
```

Это круто. В основной функции мы создали разные типы Book и Count, но передали их одной функции WriteLog(). А та вызвала соответствующие функции String() и записала результаты в журнал.

Есть целый ряд причин, по которым вы можете начать использовать интерфейсы в Go. И по моему опыту, самые важные из них такие:

1. Интерфейсы помогают уменьшить дублирование, то есть количество шаблонного кода.
2. Они облегчают использование в модульных тестах заглушек вместо реальных объектов.
3. Будучи архитектурным инструментом, интерфейсы помогают отвязывать части вашей кодовой базы.

# 3. Чем отличаюютя RWMutex от Mutex

Mutex означает mutual exclusion(взаимное исключение) и является способом защиты critical section(критическая секция) вашей программы.

![alt text](images/mutex.webp)

Критическая секция — это область вашей программы, которая требует эксклюзивного доступа к общему ресурсу. При нахождении в критической секции двух (или более) потоков возникает состояние race(гонки). Так же возможны проблемы взаимной блокировки(deadlock).

Mutex обеспечивает безопасный доступ к общим ресурсам.

RWMutex концептуально то же самое, что и Mutex: он защищает доступ к памяти. Тем не менее, RWMutex дает вам немного больше контроля над памятью. Вы можете запросить блокировку для чтения, и в этом случае вам будет предоставлен доступ, если блокировка не удерживается для записи.

Это означает, что произвольное число читателей может удерживать блокировку читателя, пока ничто другое не удерживает блокировку писателя.

Посмотрим как это работает:

```go
func (c *counter) CountV1() int {
   c.Lock()
   defer c.Unlock()
   return c.count
}
func (c *counter) CountV2() int {
   c.RLock()
   defer c.RUnlock()
   return c.count
}
```

A little bit of testing benchmark

```go
func BenchmarkCountV1(b *testing.B) {
   c := new(counter)
   var wg sync.WaitGroup
   for i := 0; i < b.N; i++ {
      for j := 0; j < 1000; j++ {
         wg.Add(1)
         go func() {
            defer wg.Done()
            c.CountV1()
         }()
      }
      wg.Wait()
   }
}

func BenchmarkCountV2(b *testing.B) {
   c := new(counter)
   var wg sync.WaitGroup
   for i := 0; i < b.N; i++ {
      for j := 0; j < 1000; j++ {
         wg.Add(1)
         go func() {
            defer wg.Done()
            c.CountV2()
         }()
      }
      wg.Wait()
   }
}
```

Results:

BenchmarkCountV1-8           2132            501896 ns/op

BenchmarkCountV2-8           3358            306254 ns/op


# 4. Чем отличаются буферизированные и не буферизированные каналы?

![alt text](images/channels.png)


# 5. Какой размер у структуры struct{}{}?

Пустая структура - это тип struct, не имеющий полей. Вот несколько примеров в именованной и анонимной формах


Пустая структура

Пустая структура имеет ширину, равную нулю. Она занимает ноль байт памяти.

Поскольку пустая структура занимает ноль байт, из этого следует, что она не нуждается в заполнении. Таким образом, структура, состоящая из пустых структур, также не занимает места.

В соответствии с принципом ортогональности (orthogonality) Go, пустая структура - это такой же тип структуры, как и любой другой. Все свойства, привычные для обычных структур, одинаково применимы к пустой структуре.

Слайс struct{} занимает только места сколько занимает его заголовок(header). Как было показано выше, их массив, содержащий пустые структуры не занимает места.

Все это справедливо и для подслайса (subslice). len и cap работают, как и ожидается.

# 6. Есть ли в Go перегрузка методов или операторов?

Нет.

# 7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1 m[1]=124 m[2]=281

Рандомно.

# 8. В чем разница make и new

new обычно используется, когда вам нужен указатель на значение определенного типа. make используется, когда вам нужно инициализировать срезы, карты или каналы, для которых требуется не только выделение памяти, но и инициализация их нулевыми значениями
# 9. Сколько существует способов задать перенную типа slice или map

# 10. Что выведет данная программа и почему?

```go
func update(p *int) { 
    b := 2
    p = &b
}

func main() { 
    var (
        a=1
        p = &a 
    )
    fmt.Println(*p) 
    update(p) 
    fmt.Println(*p)
}

Программа выведет 1 и 1. Мы изменяем значение указателя p внутри функции update, это не затрагивает значение указателя в main. Если хотим, чтобы p указывал на локальную переменную b после функции update, то нужно вернуть указатель на p из функции update. 

```

# 11. Что выведет данная программа и почему?

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```

Выведет 0...4 в случайном порядке, потом случится deadlock, т.к. в горутину передается WaitGroup по значению, поэтому сигнализация об выполнении элемента группы. Метод Wait() ожидает завершения всех горутин из группы, но внутренний счетчик в WaitGroup будет равен 5, поэтому главный поток блокируется навсегда.

# 12. Что выведет данная программа и почему?

```go
package main

import "fmt"

func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}
```

Выведется 0. Создается переменная в локальной области видимости, она и будет инкрементироваться в блоке if.

# 13. Что выведет данная программа и почему?

```go
package main

import "fmt"

func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}
func main() {
	var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
	fmt.Println(a)
}
```

Выведется 100 2 3 4 5. Чтобы добавился новый элемент, нужно вернуть из функции слайс, он имеет уже новый адрес из реалокации памяти но новый адрес. Однако значение в нулевом индексе изменится, т.к. слайс изначально передается по указателю.


# 14. Что выведет данная программа и почему?

```go
package main

import "fmt"

func main() {
	slice := []string{"a", "a"}
	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Print(slice)
	}(slice)
	fmt.Print(slice)
}
```

Выведется [b b a] [a a]. Элемент "a" не добавится, т.к. возвращаемый слайс после операции `slice = append(slice, "a")` будет иметь другой адрес, т.к. происходит реаллокация слайса на новую область памяти.